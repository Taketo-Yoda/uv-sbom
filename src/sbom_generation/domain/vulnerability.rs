use crate::shared::Result;

/// Represents a single vulnerability (CVE) affecting a package
///
/// Note: This is currently unused but will be utilized in subsequent subtasks
/// (Subtask 2-8) for the CVE check feature implementation.
#[allow(dead_code)]
#[derive(Debug, Clone, PartialEq)]
pub struct Vulnerability {
    /// Vulnerability ID (e.g., "CVE-2024-1234", "GHSA-xxxx-xxxx-xxxx")
    id: String,

    /// CVSS score (0.0 to 10.0)
    cvss_score: Option<f32>,

    /// Severity level (CRITICAL, HIGH, MEDIUM, LOW)
    severity: Severity,

    /// Version that fixes this vulnerability
    fixed_version: Option<String>,

    /// Brief summary of the vulnerability
    summary: Option<String>,
}

#[allow(dead_code)]
impl Vulnerability {
    /// Creates a new Vulnerability with validation
    ///
    /// # Arguments
    /// * `id` - Vulnerability identifier (must not be empty)
    /// * `cvss_score` - CVSS score between 0.0 and 10.0 (optional)
    /// * `severity` - Severity level
    /// * `fixed_version` - Version that fixes the vulnerability (optional)
    /// * `summary` - Brief description (optional)
    ///
    /// # Errors
    /// Returns error if:
    /// - ID is empty
    /// - CVSS score is outside valid range (0.0-10.0)
    pub fn new(
        id: String,
        cvss_score: Option<f32>,
        severity: Severity,
        fixed_version: Option<String>,
        summary: Option<String>,
    ) -> Result<Self> {
        // Validate ID
        if id.is_empty() {
            anyhow::bail!("Vulnerability ID cannot be empty");
        }

        // Validate CVSS score if present
        if let Some(score) = cvss_score {
            if !(0.0..=10.0).contains(&score) {
                anyhow::bail!("CVSS score must be between 0.0 and 10.0, got: {}", score);
            }
        }

        Ok(Self {
            id,
            cvss_score,
            severity,
            fixed_version,
            summary,
        })
    }

    /// Returns the vulnerability ID
    pub fn id(&self) -> &str {
        &self.id
    }

    /// Returns the CVSS score if available
    pub fn cvss_score(&self) -> Option<f32> {
        self.cvss_score
    }

    /// Returns the severity level
    pub fn severity(&self) -> Severity {
        self.severity
    }

    /// Returns the fixed version if available
    pub fn fixed_version(&self) -> Option<&str> {
        self.fixed_version.as_deref()
    }

    /// Returns the summary if available
    pub fn summary(&self) -> Option<&str> {
        self.summary.as_deref()
    }
}

/// Severity levels based on CVSS scores
///
/// Note: This is currently unused but will be utilized in subsequent subtasks
/// (Subtask 2-8) for the CVE check feature implementation.
#[allow(dead_code)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum Severity {
    None,     // CVSS 0.0 or unknown
    Low,      // CVSS 0.1-3.9
    Medium,   // CVSS 4.0-6.9
    High,     // CVSS 7.0-8.9
    Critical, // CVSS 9.0-10.0
}

#[allow(dead_code)]
impl Severity {
    /// Converts CVSS score to severity level
    ///
    /// CVSS Score Ranges:
    /// - 0.0: None
    /// - 0.1-3.9: Low
    /// - 4.0-6.9: Medium
    /// - 7.0-8.9: High
    /// - 9.0-10.0: Critical
    pub fn from_cvss_score(score: f32) -> Self {
        match score {
            0.0 => Self::None,
            s if s < 4.0 => Self::Low,
            s if s < 7.0 => Self::Medium,
            s if s < 9.0 => Self::High,
            _ => Self::Critical,
        }
    }

    /// Returns emoji representation for display
    pub fn emoji(&self) -> &str {
        match self {
            Self::Critical => "ðŸ”´",
            Self::High => "ðŸŸ ",
            Self::Medium => "ðŸŸ¡",
            Self::Low => "ðŸŸ¢",
            Self::None => "âšª",
        }
    }

    /// Returns color indicator for terminal output
    pub fn color(&self) -> &str {
        match self {
            Self::Critical => "red",
            Self::High => "orange",
            Self::Medium => "yellow",
            Self::Low => "green",
            Self::None => "gray",
        }
    }
}

/// Represents vulnerability information for a specific package
///
/// Note: This is currently unused but will be utilized in subsequent subtasks
/// (Subtask 2-8) for the CVE check feature implementation.
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageVulnerabilities {
    /// Package name
    package_name: String,

    /// Current version
    current_version: String,

    /// List of vulnerabilities affecting this package version
    vulnerabilities: Vec<Vulnerability>,
}

#[allow(dead_code)]
impl PackageVulnerabilities {
    /// Creates a new PackageVulnerabilities
    ///
    /// # Arguments
    /// * `package_name` - Name of the package
    /// * `current_version` - Current version of the package
    /// * `vulnerabilities` - List of vulnerabilities affecting this version
    pub fn new(
        package_name: String,
        current_version: String,
        vulnerabilities: Vec<Vulnerability>,
    ) -> Self {
        Self {
            package_name,
            current_version,
            vulnerabilities,
        }
    }

    /// Returns true if package has any vulnerabilities
    pub fn has_vulnerabilities(&self) -> bool {
        !self.vulnerabilities.is_empty()
    }

    /// Returns the highest severity among all vulnerabilities
    ///
    /// Returns `Severity::None` if there are no vulnerabilities
    pub fn max_severity(&self) -> Severity {
        self.vulnerabilities
            .iter()
            .map(|v| v.severity())
            .max()
            .unwrap_or(Severity::None)
    }

    /// Returns the package name
    pub fn package_name(&self) -> &str {
        &self.package_name
    }

    /// Returns the current version
    pub fn current_version(&self) -> &str {
        &self.current_version
    }

    /// Returns the list of vulnerabilities
    pub fn vulnerabilities(&self) -> &[Vulnerability] {
        &self.vulnerabilities
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vulnerability_new_valid() {
        let vuln = Vulnerability::new(
            "CVE-2024-1234".to_string(),
            Some(9.8),
            Severity::Critical,
            Some("2.0.0".to_string()),
            Some("SQL injection vulnerability".to_string()),
        );
        assert!(vuln.is_ok());

        let vuln = vuln.unwrap();
        assert_eq!(vuln.id(), "CVE-2024-1234");
        assert_eq!(vuln.cvss_score(), Some(9.8));
        assert_eq!(vuln.severity(), Severity::Critical);
        assert_eq!(vuln.fixed_version(), Some("2.0.0"));
        assert_eq!(vuln.summary(), Some("SQL injection vulnerability"));
    }

    #[test]
    fn test_vulnerability_empty_id() {
        let result = Vulnerability::new("".to_string(), Some(5.0), Severity::Medium, None, None);
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("ID cannot be empty"));
    }

    #[test]
    fn test_vulnerability_invalid_cvss_too_high() {
        let result = Vulnerability::new(
            "CVE-2024-1234".to_string(),
            Some(11.0),
            Severity::Critical,
            None,
            None,
        );
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("between 0.0 and 10.0"));
    }

    #[test]
    fn test_vulnerability_invalid_cvss_negative() {
        let result = Vulnerability::new(
            "CVE-2024-1234".to_string(),
            Some(-1.0),
            Severity::Critical,
            None,
            None,
        );
        assert!(result.is_err());
        assert!(result
            .unwrap_err()
            .to_string()
            .contains("between 0.0 and 10.0"));
    }

    #[test]
    fn test_vulnerability_without_optional_fields() {
        let vuln = Vulnerability::new(
            "GHSA-xxxx-yyyy-zzzz".to_string(),
            None,
            Severity::High,
            None,
            None,
        );
        assert!(vuln.is_ok());

        let vuln = vuln.unwrap();
        assert_eq!(vuln.id(), "GHSA-xxxx-yyyy-zzzz");
        assert_eq!(vuln.cvss_score(), None);
        assert_eq!(vuln.fixed_version(), None);
        assert_eq!(vuln.summary(), None);
    }

    #[test]
    fn test_severity_from_cvss_score() {
        assert_eq!(Severity::from_cvss_score(0.0), Severity::None);
        assert_eq!(Severity::from_cvss_score(0.1), Severity::Low);
        assert_eq!(Severity::from_cvss_score(3.9), Severity::Low);
        assert_eq!(Severity::from_cvss_score(4.0), Severity::Medium);
        assert_eq!(Severity::from_cvss_score(6.9), Severity::Medium);
        assert_eq!(Severity::from_cvss_score(7.0), Severity::High);
        assert_eq!(Severity::from_cvss_score(8.9), Severity::High);
        assert_eq!(Severity::from_cvss_score(9.0), Severity::Critical);
        assert_eq!(Severity::from_cvss_score(10.0), Severity::Critical);
    }

    #[test]
    fn test_severity_emoji() {
        assert_eq!(Severity::Critical.emoji(), "ðŸ”´");
        assert_eq!(Severity::High.emoji(), "ðŸŸ ");
        assert_eq!(Severity::Medium.emoji(), "ðŸŸ¡");
        assert_eq!(Severity::Low.emoji(), "ðŸŸ¢");
        assert_eq!(Severity::None.emoji(), "âšª");
    }

    #[test]
    fn test_severity_color() {
        assert_eq!(Severity::Critical.color(), "red");
        assert_eq!(Severity::High.color(), "orange");
        assert_eq!(Severity::Medium.color(), "yellow");
        assert_eq!(Severity::Low.color(), "green");
        assert_eq!(Severity::None.color(), "gray");
    }

    #[test]
    fn test_severity_ordering() {
        assert!(Severity::Critical > Severity::High);
        assert!(Severity::High > Severity::Medium);
        assert!(Severity::Medium > Severity::Low);
        assert!(Severity::Low > Severity::None);
    }

    #[test]
    fn test_package_vulnerabilities_new() {
        let vuln1 = Vulnerability::new(
            "CVE-2024-1234".to_string(),
            Some(9.8),
            Severity::Critical,
            Some("2.0.0".to_string()),
            None,
        )
        .unwrap();

        let vuln2 = Vulnerability::new(
            "CVE-2024-5678".to_string(),
            Some(5.0),
            Severity::Medium,
            Some("2.1.0".to_string()),
            None,
        )
        .unwrap();

        let pkg_vulns = PackageVulnerabilities::new(
            "requests".to_string(),
            "1.0.0".to_string(),
            vec![vuln1, vuln2],
        );

        assert_eq!(pkg_vulns.package_name(), "requests");
        assert_eq!(pkg_vulns.current_version(), "1.0.0");
        assert_eq!(pkg_vulns.vulnerabilities().len(), 2);
    }

    #[test]
    fn test_package_vulnerabilities_has_vulnerabilities() {
        let pkg_vulns =
            PackageVulnerabilities::new("safe-package".to_string(), "1.0.0".to_string(), vec![]);
        assert!(!pkg_vulns.has_vulnerabilities());

        let vuln = Vulnerability::new(
            "CVE-2024-1234".to_string(),
            Some(5.0),
            Severity::Medium,
            None,
            None,
        )
        .unwrap();

        let pkg_vulns = PackageVulnerabilities::new(
            "unsafe-package".to_string(),
            "1.0.0".to_string(),
            vec![vuln],
        );
        assert!(pkg_vulns.has_vulnerabilities());
    }

    #[test]
    fn test_package_vulnerabilities_max_severity() {
        // Empty vulnerabilities
        let pkg_vulns =
            PackageVulnerabilities::new("safe-package".to_string(), "1.0.0".to_string(), vec![]);
        assert_eq!(pkg_vulns.max_severity(), Severity::None);

        // Multiple vulnerabilities
        let vuln1 =
            Vulnerability::new("CVE-1".to_string(), Some(5.0), Severity::Medium, None, None)
                .unwrap();

        let vuln2 = Vulnerability::new(
            "CVE-2".to_string(),
            Some(9.8),
            Severity::Critical,
            None,
            None,
        )
        .unwrap();

        let vuln3 =
            Vulnerability::new("CVE-3".to_string(), Some(7.5), Severity::High, None, None).unwrap();

        let pkg_vulns = PackageVulnerabilities::new(
            "package".to_string(),
            "1.0.0".to_string(),
            vec![vuln1, vuln2, vuln3],
        );
        assert_eq!(pkg_vulns.max_severity(), Severity::Critical);
    }
}
