use super::super::vulnerability::{PackageVulnerabilities, Severity, Vulnerability};
use crate::config::IgnoreCve;

/// Represents a flattened vulnerability row for display purposes
///
/// This struct provides a presentation-ready format for vulnerability data,
/// enabling consistent sorting and display across different formatters.
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VulnerabilityRow {
    /// Package name affected by the vulnerability
    pub package_name: String,
    /// Current installed version of the package
    pub current_version: String,
    /// Version that fixes the vulnerability (or "N/A" if unknown)
    pub fixed_version: String,
    /// CVSS score as display string (e.g., "9.8" or "N/A")
    pub cvss_display: String,
    /// Severity level of the vulnerability
    pub severity: Severity,
    /// CVE or vulnerability identifier
    pub cve_id: String,
}

/// Configuration for threshold evaluation
#[derive(Debug, Clone, PartialEq)]
pub enum ThresholdConfig {
    /// No threshold - all vulnerabilities trigger exit code 1
    None,
    /// Threshold based on severity level
    Severity(Severity),
    /// Threshold based on CVSS score
    Cvss(f32),
}

/// Result of vulnerability threshold check
#[derive(Debug, Clone)]
pub struct VulnerabilityCheckResult {
    /// Packages with vulnerabilities above the threshold
    pub above_threshold: Vec<PackageVulnerabilities>,
    /// Packages with vulnerabilities below the threshold
    pub below_threshold: Vec<PackageVulnerabilities>,
    /// Whether any vulnerability exceeded the threshold
    pub threshold_exceeded: bool,
}

impl VulnerabilityCheckResult {
    /// Returns true if there are actionable vulnerabilities (above threshold)
    #[allow(dead_code)]
    pub fn has_actionable_vulnerabilities(&self) -> bool {
        !self.above_threshold.is_empty()
    }

    /// Returns true if there are informational vulnerabilities (below threshold)
    #[allow(dead_code)]
    pub fn has_informational_vulnerabilities(&self) -> bool {
        !self.below_threshold.is_empty()
    }

    /// Returns total count of actionable vulnerabilities
    pub fn actionable_count(&self) -> usize {
        self.above_threshold
            .iter()
            .map(|pv| pv.vulnerabilities().len())
            .sum()
    }

    /// Returns total count of informational vulnerabilities
    pub fn informational_count(&self) -> usize {
        self.below_threshold
            .iter()
            .map(|pv| pv.vulnerabilities().len())
            .sum()
    }

    /// Returns affected package count for actionable vulnerabilities
    #[allow(dead_code)]
    pub fn actionable_package_count(&self) -> usize {
        self.above_threshold.len()
    }

    /// Returns affected package count for informational vulnerabilities
    #[allow(dead_code)]
    pub fn informational_package_count(&self) -> usize {
        self.below_threshold.len()
    }
}

/// Domain service for evaluating vulnerabilities against thresholds
pub struct VulnerabilityChecker;

impl VulnerabilityChecker {
    /// Returns vulnerabilities sorted by severity (Critical first, then High, Medium, Low, None)
    ///
    /// This method flattens package vulnerabilities into individual rows and sorts them
    /// by severity in descending order for consistent display across formatters.
    ///
    /// # Arguments
    /// * `vulnerabilities` - List of package vulnerabilities to sort
    ///
    /// # Returns
    /// Vector of VulnerabilityRow sorted by severity (Critical first)
    #[allow(dead_code)]
    pub fn sort_by_severity(vulnerabilities: &[PackageVulnerabilities]) -> Vec<VulnerabilityRow> {
        let mut rows: Vec<VulnerabilityRow> = vulnerabilities
            .iter()
            .flat_map(|pv| {
                pv.vulnerabilities()
                    .iter()
                    .map(move |vuln| VulnerabilityRow {
                        package_name: pv.package_name().to_string(),
                        current_version: pv.current_version().to_string(),
                        fixed_version: vuln.fixed_version().unwrap_or("N/A").to_string(),
                        cvss_display: vuln
                            .cvss_score()
                            .map_or("N/A".to_string(), |s| format!("{:.1}", s.value())),
                        severity: vuln.severity(),
                        cve_id: vuln.id().to_string(),
                    })
            })
            .collect();

        rows.sort_by(|a, b| b.severity.cmp(&a.severity));
        rows
    }

    /// Checks vulnerabilities against the specified threshold, after filtering ignored CVEs
    ///
    /// # Arguments
    /// * `vulnerabilities` - List of package vulnerabilities to check
    /// * `threshold` - Threshold configuration
    /// * `ignore_cves` - List of CVE IDs to ignore (excluded before threshold evaluation)
    ///
    /// # Returns
    /// VulnerabilityCheckResult with above/below threshold separation
    pub fn check(
        vulnerabilities: Vec<PackageVulnerabilities>,
        threshold: ThresholdConfig,
        ignore_cves: &[IgnoreCve],
    ) -> VulnerabilityCheckResult {
        // Step 1: Filter out ignored CVEs
        let filtered = Self::filter_ignored_cves(vulnerabilities, ignore_cves);

        // Step 2: Apply threshold evaluation
        let mut above_threshold = Vec::new();
        let mut below_threshold = Vec::new();

        for pkg_vulns in filtered {
            let (above, below) = Self::partition_vulnerabilities(&pkg_vulns, &threshold);

            if !above.is_empty() {
                above_threshold.push(PackageVulnerabilities::new(
                    pkg_vulns.package_name().to_string(),
                    pkg_vulns.current_version().to_string(),
                    above,
                ));
            }

            if !below.is_empty() {
                below_threshold.push(PackageVulnerabilities::new(
                    pkg_vulns.package_name().to_string(),
                    pkg_vulns.current_version().to_string(),
                    below,
                ));
            }
        }

        let threshold_exceeded = !above_threshold.is_empty();

        VulnerabilityCheckResult {
            above_threshold,
            below_threshold,
            threshold_exceeded,
        }
    }

    /// Filters out ignored CVEs from vulnerability results
    ///
    /// Removes vulnerabilities whose IDs match the ignore list (exact, case-sensitive).
    /// Logs each ignored CVE to stderr for transparency.
    ///
    /// # Arguments
    /// * `vulnerabilities` - List of package vulnerabilities to filter
    /// * `ignore_cves` - List of CVE entries to ignore
    ///
    /// # Returns
    /// Filtered list with ignored CVEs removed (packages with no remaining vulns are dropped)
    fn filter_ignored_cves(
        vulnerabilities: Vec<PackageVulnerabilities>,
        ignore_cves: &[IgnoreCve],
    ) -> Vec<PackageVulnerabilities> {
        if ignore_cves.is_empty() {
            return vulnerabilities;
        }

        let ignore_ids: std::collections::HashSet<&str> =
            ignore_cves.iter().map(|c| c.id.as_str()).collect();

        let mut result = Vec::new();

        for pkg_vulns in vulnerabilities {
            let mut kept = Vec::new();

            for vuln in pkg_vulns.vulnerabilities() {
                if ignore_ids.contains(vuln.id()) {
                    // Find the matching ignore entry to get the reason
                    let reason = ignore_cves
                        .iter()
                        .find(|c| c.id == vuln.id())
                        .and_then(|c| c.reason());

                    match reason {
                        Some(r) => eprintln!(
                            "⚠ Ignored {} for package {} (reason: {})",
                            vuln.id(),
                            pkg_vulns.package_name(),
                            r
                        ),
                        None => eprintln!(
                            "⚠ Ignored {} for package {} (no reason provided)",
                            vuln.id(),
                            pkg_vulns.package_name()
                        ),
                    }
                } else {
                    kept.push(vuln.clone());
                }
            }

            if !kept.is_empty() {
                result.push(PackageVulnerabilities::new(
                    pkg_vulns.package_name().to_string(),
                    pkg_vulns.current_version().to_string(),
                    kept,
                ));
            }
        }

        result
    }

    /// Partitions vulnerabilities into above and below threshold
    fn partition_vulnerabilities(
        pkg_vulns: &PackageVulnerabilities,
        threshold: &ThresholdConfig,
    ) -> (Vec<Vulnerability>, Vec<Vulnerability>) {
        let mut above = Vec::new();
        let mut below = Vec::new();

        for vuln in pkg_vulns.vulnerabilities() {
            if Self::is_above_threshold(vuln, threshold) {
                above.push(vuln.clone());
            } else {
                below.push(vuln.clone());
            }
        }

        (above, below)
    }

    /// Determines if a vulnerability is above the specified threshold
    fn is_above_threshold(vuln: &Vulnerability, threshold: &ThresholdConfig) -> bool {
        match threshold {
            ThresholdConfig::None => true,
            ThresholdConfig::Severity(min_severity) => vuln.severity() >= *min_severity,
            ThresholdConfig::Cvss(min_cvss) => {
                // N/A CVSS scores are excluded from threshold evaluation
                match vuln.cvss_score() {
                    Some(score) => score.value() >= *min_cvss,
                    None => false,
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::sbom_generation::domain::vulnerability::CvssScore;

    fn create_vulnerability(id: &str, cvss: Option<f32>, severity: Severity) -> Vulnerability {
        let cvss_score = cvss.map(|s| CvssScore::new(s).unwrap());
        Vulnerability::new(id.to_string(), cvss_score, severity, None, None).unwrap()
    }

    fn create_package_vulnerabilities(
        name: &str,
        vulnerabilities: Vec<Vulnerability>,
    ) -> PackageVulnerabilities {
        PackageVulnerabilities::new(name.to_string(), "1.0.0".to_string(), vulnerabilities)
    }

    #[test]
    fn test_threshold_none_all_above() {
        let vuln1 = create_vulnerability("CVE-2024-001", Some(3.0), Severity::Low);
        let vuln2 = create_vulnerability("CVE-2024-002", Some(9.8), Severity::Critical);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln1, vuln2]);

        let result = VulnerabilityChecker::check(vec![pkg], ThresholdConfig::None, &[]);

        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold.len(), 1);
        assert_eq!(result.above_threshold[0].vulnerabilities().len(), 2);
        assert!(result.below_threshold.is_empty());
    }

    #[test]
    fn test_threshold_severity_high() {
        let vuln_low = create_vulnerability("CVE-2024-001", Some(3.0), Severity::Low);
        let vuln_medium = create_vulnerability("CVE-2024-002", Some(5.0), Severity::Medium);
        let vuln_high = create_vulnerability("CVE-2024-003", Some(7.5), Severity::High);
        let vuln_critical = create_vulnerability("CVE-2024-004", Some(9.8), Severity::Critical);
        let pkg = create_package_vulnerabilities(
            "test-pkg",
            vec![vuln_low, vuln_medium, vuln_high, vuln_critical],
        );

        let result =
            VulnerabilityChecker::check(vec![pkg], ThresholdConfig::Severity(Severity::High), &[]);

        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold.len(), 1);
        assert_eq!(result.above_threshold[0].vulnerabilities().len(), 2); // High and Critical
        assert_eq!(result.below_threshold.len(), 1);
        assert_eq!(result.below_threshold[0].vulnerabilities().len(), 2); // Low and Medium
    }

    #[test]
    fn test_threshold_severity_critical_only() {
        let vuln_high = create_vulnerability("CVE-2024-001", Some(8.0), Severity::High);
        let vuln_critical = create_vulnerability("CVE-2024-002", Some(9.8), Severity::Critical);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln_high, vuln_critical]);

        let result = VulnerabilityChecker::check(
            vec![pkg],
            ThresholdConfig::Severity(Severity::Critical),
            &[],
        );

        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold.len(), 1);
        assert_eq!(result.above_threshold[0].vulnerabilities().len(), 1); // Critical only
        assert_eq!(result.below_threshold.len(), 1);
        assert_eq!(result.below_threshold[0].vulnerabilities().len(), 1); // High only
    }

    #[test]
    fn test_threshold_cvss() {
        let vuln_low = create_vulnerability("CVE-2024-001", Some(3.0), Severity::Low);
        let vuln_high = create_vulnerability("CVE-2024-002", Some(7.5), Severity::High);
        let vuln_critical = create_vulnerability("CVE-2024-003", Some(9.8), Severity::Critical);
        let pkg =
            create_package_vulnerabilities("test-pkg", vec![vuln_low, vuln_high, vuln_critical]);

        let result = VulnerabilityChecker::check(vec![pkg], ThresholdConfig::Cvss(7.0), &[]);

        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold.len(), 1);
        assert_eq!(result.above_threshold[0].vulnerabilities().len(), 2); // 7.5 and 9.8
        assert_eq!(result.below_threshold.len(), 1);
        assert_eq!(result.below_threshold[0].vulnerabilities().len(), 1); // 3.0
    }

    #[test]
    fn test_threshold_cvss_na_excluded() {
        let vuln_with_cvss = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let vuln_without_cvss = create_vulnerability("CVE-2024-002", None, Severity::High);
        let pkg =
            create_package_vulnerabilities("test-pkg", vec![vuln_with_cvss, vuln_without_cvss]);

        let result = VulnerabilityChecker::check(vec![pkg], ThresholdConfig::Cvss(7.0), &[]);

        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold.len(), 1);
        assert_eq!(result.above_threshold[0].vulnerabilities().len(), 1); // Only with CVSS
        assert_eq!(result.below_threshold.len(), 1);
        assert_eq!(result.below_threshold[0].vulnerabilities().len(), 1); // N/A excluded
    }

    #[test]
    fn test_no_vulnerabilities_above_threshold() {
        let vuln_low = create_vulnerability("CVE-2024-001", Some(3.0), Severity::Low);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln_low]);

        let result =
            VulnerabilityChecker::check(vec![pkg], ThresholdConfig::Severity(Severity::High), &[]);

        assert!(!result.threshold_exceeded);
        assert!(result.above_threshold.is_empty());
        assert_eq!(result.below_threshold.len(), 1);
    }

    #[test]
    fn test_empty_input() {
        let result = VulnerabilityChecker::check(vec![], ThresholdConfig::None, &[]);

        assert!(!result.threshold_exceeded);
        assert!(result.above_threshold.is_empty());
        assert!(result.below_threshold.is_empty());
    }

    #[test]
    fn test_multiple_packages() {
        let vuln1 = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let vuln2 = create_vulnerability("CVE-2024-002", Some(3.0), Severity::Low);
        let pkg1 = create_package_vulnerabilities("pkg-1", vec![vuln1]);
        let pkg2 = create_package_vulnerabilities("pkg-2", vec![vuln2]);

        let result = VulnerabilityChecker::check(
            vec![pkg1, pkg2],
            ThresholdConfig::Severity(Severity::High),
            &[],
        );

        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold.len(), 1);
        assert_eq!(result.above_threshold[0].package_name(), "pkg-1");
        assert_eq!(result.below_threshold.len(), 1);
        assert_eq!(result.below_threshold[0].package_name(), "pkg-2");
    }

    #[test]
    fn test_threshold_cvss_boundary() {
        let vuln_at_threshold = create_vulnerability("CVE-2024-001", Some(7.0), Severity::High);
        let vuln_below_threshold =
            create_vulnerability("CVE-2024-002", Some(6.9), Severity::Medium);
        let pkg = create_package_vulnerabilities(
            "test-pkg",
            vec![vuln_at_threshold, vuln_below_threshold],
        );

        let result = VulnerabilityChecker::check(vec![pkg], ThresholdConfig::Cvss(7.0), &[]);

        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold[0].vulnerabilities().len(), 1); // 7.0 is >= 7.0
        assert_eq!(result.below_threshold[0].vulnerabilities().len(), 1); // 6.9 is < 7.0
    }

    // Tests for VulnerabilityCheckResult semantic methods

    #[test]
    fn test_has_actionable_vulnerabilities_true() {
        let vuln = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln]);

        let result = VulnerabilityCheckResult {
            above_threshold: vec![pkg],
            below_threshold: vec![],
            threshold_exceeded: true,
        };

        assert!(result.has_actionable_vulnerabilities());
    }

    #[test]
    fn test_has_actionable_vulnerabilities_false() {
        let result = VulnerabilityCheckResult {
            above_threshold: vec![],
            below_threshold: vec![],
            threshold_exceeded: false,
        };

        assert!(!result.has_actionable_vulnerabilities());
    }

    #[test]
    fn test_has_informational_vulnerabilities_true() {
        let vuln = create_vulnerability("CVE-2024-001", Some(3.0), Severity::Low);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln]);

        let result = VulnerabilityCheckResult {
            above_threshold: vec![],
            below_threshold: vec![pkg],
            threshold_exceeded: false,
        };

        assert!(result.has_informational_vulnerabilities());
    }

    #[test]
    fn test_has_informational_vulnerabilities_false() {
        let result = VulnerabilityCheckResult {
            above_threshold: vec![],
            below_threshold: vec![],
            threshold_exceeded: false,
        };

        assert!(!result.has_informational_vulnerabilities());
    }

    #[test]
    fn test_actionable_count_single_package() {
        let vuln1 = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let vuln2 = create_vulnerability("CVE-2024-002", Some(8.0), Severity::High);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln1, vuln2]);

        let result = VulnerabilityCheckResult {
            above_threshold: vec![pkg],
            below_threshold: vec![],
            threshold_exceeded: true,
        };

        assert_eq!(result.actionable_count(), 2);
    }

    #[test]
    fn test_actionable_count_multiple_packages() {
        let vuln1 = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let vuln2 = create_vulnerability("CVE-2024-002", Some(8.0), Severity::High);
        let vuln3 = create_vulnerability("CVE-2024-003", Some(7.5), Severity::High);
        let pkg1 = create_package_vulnerabilities("pkg-1", vec![vuln1, vuln2]);
        let pkg2 = create_package_vulnerabilities("pkg-2", vec![vuln3]);

        let result = VulnerabilityCheckResult {
            above_threshold: vec![pkg1, pkg2],
            below_threshold: vec![],
            threshold_exceeded: true,
        };

        assert_eq!(result.actionable_count(), 3);
    }

    #[test]
    fn test_actionable_count_empty() {
        let result = VulnerabilityCheckResult {
            above_threshold: vec![],
            below_threshold: vec![],
            threshold_exceeded: false,
        };

        assert_eq!(result.actionable_count(), 0);
    }

    #[test]
    fn test_informational_count_single_package() {
        let vuln1 = create_vulnerability("CVE-2024-001", Some(3.0), Severity::Low);
        let vuln2 = create_vulnerability("CVE-2024-002", Some(2.0), Severity::Low);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln1, vuln2]);

        let result = VulnerabilityCheckResult {
            above_threshold: vec![],
            below_threshold: vec![pkg],
            threshold_exceeded: false,
        };

        assert_eq!(result.informational_count(), 2);
    }

    #[test]
    fn test_informational_count_multiple_packages() {
        let vuln1 = create_vulnerability("CVE-2024-001", Some(3.0), Severity::Low);
        let vuln2 = create_vulnerability("CVE-2024-002", Some(5.0), Severity::Medium);
        let vuln3 = create_vulnerability("CVE-2024-003", Some(4.0), Severity::Medium);
        let pkg1 = create_package_vulnerabilities("pkg-1", vec![vuln1]);
        let pkg2 = create_package_vulnerabilities("pkg-2", vec![vuln2, vuln3]);

        let result = VulnerabilityCheckResult {
            above_threshold: vec![],
            below_threshold: vec![pkg1, pkg2],
            threshold_exceeded: false,
        };

        assert_eq!(result.informational_count(), 3);
    }

    #[test]
    fn test_actionable_package_count() {
        let vuln1 = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let vuln2 = create_vulnerability("CVE-2024-002", Some(8.0), Severity::High);
        let pkg1 = create_package_vulnerabilities("pkg-1", vec![vuln1]);
        let pkg2 = create_package_vulnerabilities("pkg-2", vec![vuln2]);

        let result = VulnerabilityCheckResult {
            above_threshold: vec![pkg1, pkg2],
            below_threshold: vec![],
            threshold_exceeded: true,
        };

        assert_eq!(result.actionable_package_count(), 2);
    }

    #[test]
    fn test_actionable_package_count_empty() {
        let result = VulnerabilityCheckResult {
            above_threshold: vec![],
            below_threshold: vec![],
            threshold_exceeded: false,
        };

        assert_eq!(result.actionable_package_count(), 0);
    }

    #[test]
    fn test_informational_package_count() {
        let vuln1 = create_vulnerability("CVE-2024-001", Some(3.0), Severity::Low);
        let vuln2 = create_vulnerability("CVE-2024-002", Some(4.0), Severity::Medium);
        let vuln3 = create_vulnerability("CVE-2024-003", Some(2.0), Severity::Low);
        let pkg1 = create_package_vulnerabilities("pkg-1", vec![vuln1]);
        let pkg2 = create_package_vulnerabilities("pkg-2", vec![vuln2]);
        let pkg3 = create_package_vulnerabilities("pkg-3", vec![vuln3]);

        let result = VulnerabilityCheckResult {
            above_threshold: vec![],
            below_threshold: vec![pkg1, pkg2, pkg3],
            threshold_exceeded: false,
        };

        assert_eq!(result.informational_package_count(), 3);
    }

    #[test]
    fn test_semantic_methods_with_mixed_result() {
        let vuln_critical = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let vuln_high = create_vulnerability("CVE-2024-002", Some(8.0), Severity::High);
        let vuln_low = create_vulnerability("CVE-2024-003", Some(3.0), Severity::Low);
        let vuln_medium = create_vulnerability("CVE-2024-004", Some(5.0), Severity::Medium);

        let above_pkg =
            create_package_vulnerabilities("critical-pkg", vec![vuln_critical, vuln_high]);
        let below_pkg1 = create_package_vulnerabilities("low-pkg", vec![vuln_low]);
        let below_pkg2 = create_package_vulnerabilities("medium-pkg", vec![vuln_medium]);

        let result = VulnerabilityCheckResult {
            above_threshold: vec![above_pkg],
            below_threshold: vec![below_pkg1, below_pkg2],
            threshold_exceeded: true,
        };

        assert!(result.has_actionable_vulnerabilities());
        assert!(result.has_informational_vulnerabilities());
        assert_eq!(result.actionable_count(), 2);
        assert_eq!(result.informational_count(), 2);
        assert_eq!(result.actionable_package_count(), 1);
        assert_eq!(result.informational_package_count(), 2);
    }

    // Tests for VulnerabilityChecker::sort_by_severity

    #[test]
    fn test_sort_by_severity_orders_critical_first() {
        let vuln_low = create_vulnerability("CVE-LOW", Some(2.0), Severity::Low);
        let vuln_critical = create_vulnerability("CVE-CRITICAL", Some(9.8), Severity::Critical);
        let vuln_medium = create_vulnerability("CVE-MEDIUM", Some(5.0), Severity::Medium);
        let vuln_high = create_vulnerability("CVE-HIGH", Some(8.0), Severity::High);

        let pkg = create_package_vulnerabilities(
            "test-pkg",
            vec![vuln_low, vuln_critical, vuln_medium, vuln_high],
        );

        let sorted = VulnerabilityChecker::sort_by_severity(&[pkg]);

        assert_eq!(sorted.len(), 4);
        assert_eq!(sorted[0].cve_id, "CVE-CRITICAL");
        assert_eq!(sorted[1].cve_id, "CVE-HIGH");
        assert_eq!(sorted[2].cve_id, "CVE-MEDIUM");
        assert_eq!(sorted[3].cve_id, "CVE-LOW");
    }

    #[test]
    fn test_sort_by_severity_preserves_package_info() {
        let vuln = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let pkg =
            PackageVulnerabilities::new("my-package".to_string(), "2.5.0".to_string(), vec![vuln]);

        let sorted = VulnerabilityChecker::sort_by_severity(&[pkg]);

        assert_eq!(sorted.len(), 1);
        assert_eq!(sorted[0].package_name, "my-package");
        assert_eq!(sorted[0].current_version, "2.5.0");
        assert_eq!(sorted[0].severity, Severity::Critical);
    }

    #[test]
    fn test_sort_by_severity_handles_fixed_version() {
        let vuln_with_fix = Vulnerability::new(
            "CVE-WITH-FIX".to_string(),
            Some(CvssScore::new(8.0).unwrap()),
            Severity::High,
            Some("3.0.0".to_string()),
            None,
        )
        .unwrap();

        let vuln_without_fix = Vulnerability::new(
            "CVE-NO-FIX".to_string(),
            Some(CvssScore::new(7.0).unwrap()),
            Severity::High,
            None,
            None,
        )
        .unwrap();

        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln_with_fix, vuln_without_fix]);

        let sorted = VulnerabilityChecker::sort_by_severity(&[pkg]);

        assert_eq!(sorted.len(), 2);
        let with_fix = sorted.iter().find(|r| r.cve_id == "CVE-WITH-FIX").unwrap();
        let without_fix = sorted.iter().find(|r| r.cve_id == "CVE-NO-FIX").unwrap();
        assert_eq!(with_fix.fixed_version, "3.0.0");
        assert_eq!(without_fix.fixed_version, "N/A");
    }

    #[test]
    fn test_sort_by_severity_handles_cvss_display() {
        let vuln_with_cvss = create_vulnerability("CVE-WITH-CVSS", Some(7.5), Severity::High);
        let vuln_without_cvss =
            Vulnerability::new("CVE-NO-CVSS".to_string(), None, Severity::High, None, None)
                .unwrap();

        let pkg =
            create_package_vulnerabilities("test-pkg", vec![vuln_with_cvss, vuln_without_cvss]);

        let sorted = VulnerabilityChecker::sort_by_severity(&[pkg]);

        assert_eq!(sorted.len(), 2);
        let with_cvss = sorted.iter().find(|r| r.cve_id == "CVE-WITH-CVSS").unwrap();
        let without_cvss = sorted.iter().find(|r| r.cve_id == "CVE-NO-CVSS").unwrap();
        assert_eq!(with_cvss.cvss_display, "7.5");
        assert_eq!(without_cvss.cvss_display, "N/A");
    }

    #[test]
    fn test_sort_by_severity_multiple_packages() {
        let vuln1 = create_vulnerability("CVE-PKG1-HIGH", Some(8.0), Severity::High);
        let vuln2 = create_vulnerability("CVE-PKG2-CRITICAL", Some(9.5), Severity::Critical);
        let vuln3 = create_vulnerability("CVE-PKG1-LOW", Some(2.0), Severity::Low);

        let pkg1 = create_package_vulnerabilities("pkg-1", vec![vuln1, vuln3]);
        let pkg2 = create_package_vulnerabilities("pkg-2", vec![vuln2]);

        let sorted = VulnerabilityChecker::sort_by_severity(&[pkg1, pkg2]);

        assert_eq!(sorted.len(), 3);
        // Critical should be first regardless of package
        assert_eq!(sorted[0].cve_id, "CVE-PKG2-CRITICAL");
        assert_eq!(sorted[0].package_name, "pkg-2");
        assert_eq!(sorted[1].cve_id, "CVE-PKG1-HIGH");
        assert_eq!(sorted[2].cve_id, "CVE-PKG1-LOW");
    }

    #[test]
    fn test_sort_by_severity_empty_input() {
        let sorted = VulnerabilityChecker::sort_by_severity(&[]);
        assert!(sorted.is_empty());
    }

    #[test]
    fn test_sort_by_severity_includes_none_severity() {
        let vuln_none = create_vulnerability("CVE-NONE", Some(0.0), Severity::None);
        let vuln_low = create_vulnerability("CVE-LOW", Some(2.0), Severity::Low);

        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln_none, vuln_low]);

        let sorted = VulnerabilityChecker::sort_by_severity(&[pkg]);

        assert_eq!(sorted.len(), 2);
        assert_eq!(sorted[0].cve_id, "CVE-LOW");
        assert_eq!(sorted[1].cve_id, "CVE-NONE");
    }

    // Tests for CVE ignore filtering

    #[test]
    fn test_ignore_single_cve() {
        let vuln1 = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let vuln2 = create_vulnerability("CVE-2024-002", Some(7.5), Severity::High);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln1, vuln2]);

        let ignore = vec![IgnoreCve {
            id: "CVE-2024-001".to_string(),
            reason: Some("False positive".to_string()),
        }];

        let result = VulnerabilityChecker::check(vec![pkg], ThresholdConfig::None, &ignore);

        // Only CVE-2024-002 should remain
        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold.len(), 1);
        assert_eq!(result.above_threshold[0].vulnerabilities().len(), 1);
        assert_eq!(
            result.above_threshold[0].vulnerabilities()[0].id(),
            "CVE-2024-002"
        );
    }

    #[test]
    fn test_ignore_multiple_cves() {
        let vuln1 = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let vuln2 = create_vulnerability("CVE-2024-002", Some(7.5), Severity::High);
        let vuln3 = create_vulnerability("CVE-2024-003", Some(3.0), Severity::Low);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln1, vuln2, vuln3]);

        let ignore = vec![
            IgnoreCve {
                id: "CVE-2024-001".to_string(),
                reason: None,
            },
            IgnoreCve {
                id: "CVE-2024-002".to_string(),
                reason: Some("Accepted risk".to_string()),
            },
        ];

        let result = VulnerabilityChecker::check(vec![pkg], ThresholdConfig::None, &ignore);

        // Only CVE-2024-003 should remain
        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold.len(), 1);
        assert_eq!(result.above_threshold[0].vulnerabilities().len(), 1);
        assert_eq!(
            result.above_threshold[0].vulnerabilities()[0].id(),
            "CVE-2024-003"
        );
    }

    #[test]
    fn test_ignore_cve_with_reason() {
        let vuln = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln]);

        let ignore = vec![IgnoreCve {
            id: "CVE-2024-001".to_string(),
            reason: Some("Code path not reachable".to_string()),
        }];

        let result = VulnerabilityChecker::check(vec![pkg], ThresholdConfig::None, &ignore);

        // All vulnerabilities ignored, threshold should NOT be exceeded
        assert!(!result.threshold_exceeded);
        assert!(result.above_threshold.is_empty());
        assert!(result.below_threshold.is_empty());
    }

    #[test]
    fn test_ignore_cve_no_match() {
        let vuln = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln]);

        let ignore = vec![IgnoreCve {
            id: "CVE-2024-999".to_string(),
            reason: None,
        }];

        let result = VulnerabilityChecker::check(vec![pkg], ThresholdConfig::None, &ignore);

        // No CVE matched, so CVE-2024-001 should still be present
        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold.len(), 1);
        assert_eq!(result.above_threshold[0].vulnerabilities().len(), 1);
    }

    #[test]
    fn test_ignore_cves_empty_list() {
        let vuln = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln]);

        let result = VulnerabilityChecker::check(vec![pkg], ThresholdConfig::None, &[]);

        // Empty ignore list should be a no-op
        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold.len(), 1);
    }

    #[test]
    fn test_ignore_all_cves_in_package_removes_package() {
        let vuln1 = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let vuln2 = create_vulnerability("CVE-2024-002", Some(7.5), Severity::High);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln1, vuln2]);

        let ignore = vec![
            IgnoreCve {
                id: "CVE-2024-001".to_string(),
                reason: None,
            },
            IgnoreCve {
                id: "CVE-2024-002".to_string(),
                reason: None,
            },
        ];

        let result = VulnerabilityChecker::check(vec![pkg], ThresholdConfig::None, &ignore);

        // All CVEs ignored → no packages in result
        assert!(!result.threshold_exceeded);
        assert!(result.above_threshold.is_empty());
        assert!(result.below_threshold.is_empty());
    }

    #[test]
    fn test_ignore_cve_case_sensitive() {
        let vuln = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln]);

        // Lowercase should NOT match
        let ignore = vec![IgnoreCve {
            id: "cve-2024-001".to_string(),
            reason: None,
        }];

        let result = VulnerabilityChecker::check(vec![pkg], ThresholdConfig::None, &ignore);

        // Case mismatch → no filtering applied
        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold.len(), 1);
    }

    #[test]
    fn test_ignore_cve_does_not_trigger_threshold() {
        let vuln_critical = create_vulnerability("CVE-2024-001", Some(9.8), Severity::Critical);
        let vuln_low = create_vulnerability("CVE-2024-002", Some(3.0), Severity::Low);
        let pkg = create_package_vulnerabilities("test-pkg", vec![vuln_critical, vuln_low]);

        // Ignore the critical CVE
        let ignore = vec![IgnoreCve {
            id: "CVE-2024-001".to_string(),
            reason: Some("False positive".to_string()),
        }];

        let result = VulnerabilityChecker::check(
            vec![pkg],
            ThresholdConfig::Severity(Severity::High),
            &ignore,
        );

        // Only Low remains, which is below High threshold
        assert!(!result.threshold_exceeded);
        assert!(result.above_threshold.is_empty());
        assert_eq!(result.below_threshold.len(), 1);
    }

    #[test]
    fn test_ignore_cve_across_multiple_packages() {
        let vuln1 = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let vuln2 = create_vulnerability("CVE-2024-001", Some(9.0), Severity::Critical);
        let vuln3 = create_vulnerability("CVE-2024-002", Some(7.5), Severity::High);
        let pkg1 = create_package_vulnerabilities("pkg-1", vec![vuln1]);
        let pkg2 = create_package_vulnerabilities("pkg-2", vec![vuln2, vuln3]);

        let ignore = vec![IgnoreCve {
            id: "CVE-2024-001".to_string(),
            reason: None,
        }];

        let result = VulnerabilityChecker::check(vec![pkg1, pkg2], ThresholdConfig::None, &ignore);

        // pkg-1 should be completely removed (only had CVE-2024-001)
        // pkg-2 should remain with only CVE-2024-002
        assert!(result.threshold_exceeded);
        assert_eq!(result.above_threshold.len(), 1);
        assert_eq!(result.above_threshold[0].package_name(), "pkg-2");
        assert_eq!(result.above_threshold[0].vulnerabilities().len(), 1);
        assert_eq!(
            result.above_threshold[0].vulnerabilities()[0].id(),
            "CVE-2024-002"
        );
    }
}
