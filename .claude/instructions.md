# Claude Codeへの指示

このファイルは、Claude Codeがこのプロジェクトを扱う際の具体的な指示を含みます。

## プロジェクトの性質

このプロジェクトは**Rust製のCLIツール**で、以下の特性があります:

- 言語: Rust (Edition 2021)
- ビルドシステム: Cargo
- アーキテクチャ: モジュール化された単一バイナリ
- エラーハンドリング: anyhowベース、カスタムエラー型使用

## コード変更時の注意事項

### 1. エラーハンドリング

すべてのエラーは`SbomError`型を使用し、ユーザーフレンドリーなメッセージを提供すること:

```rust
// ❌ 悪い例
return Err(anyhow::anyhow!("Failed to read file"));

// ✅ 良い例
return Err(SbomError::LockfileParseError {
    path: lockfile_path.clone(),
    details: e.to_string(),
}.into());
```

### 2. ユーザー向けメッセージ

- 進捗メッセージ: `eprintln!` を使用して標準エラー出力に表示
- エラーメッセージ: 日本語で分かりやすく、解決策を含める
- 絵文字を活用: 📖 (読み込み), ✅ (成功), ❌ (エラー), 🔍 (検索), 💡 (ヒント)

### 3. テストの追加

新機能を追加する場合は、必ず対応するテストを追加:

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_feature() {
        // テストコード
    }
}
```

### 4. ドキュメントの更新

以下のファイルを必要に応じて更新:
- `README.md`: ユーザー向けドキュメント
- `CHANGELOG.md`: 変更履歴
- `.claude/project-context.md`: プロジェクトコンテキスト
- `DEVELOPMENT.md`: 開発者向けガイド

## モジュール別のガイドライン

### main.rs
- エントリーポイントとフロー制御のみ
- ビジネスロジックは他のモジュールに委譲
- エラーハンドリングとユーザーメッセージ表示

### cli.rs
- `clap`の`derive`マクロを使用
- オプションにはデフォルト値を設定
- ヘルプメッセージは英語で簡潔に

### lockfile.rs
- TOML形式のパース
- エラーは詳細な情報を含める
- パース結果は`Vec<Package>`として返す

### license.rs
- PyPI API呼び出しは必ずリトライロジックを通す
- 進捗表示を更新
- 失敗してもパッケージを除外しない

### cyclonedx.rs, markdown.rs
- 出力形式の生成のみ
- 外部APIとの通信は行わない
- テストで出力形式を検証

### error.rs
- 新しいエラー型を追加する場合、必ず解決策の提案を含める
- `Display`実装で分かりやすいメッセージを提供

## コーディングスタイル

### 命名規則
- 関数名: `snake_case`
- 型名: `PascalCase`
- 定数: `UPPER_SNAKE_CASE`

### コメント
- 公開APIには必ずドキュメントコメント (`///`)
- 複雑なロジックには説明コメント
- TODOやFIXMEは明確に

### エラーハンドリング
- `?`演算子を積極的に使用
- `unwrap()`や`expect()`は避ける (テスト以外)
- エラーコンテキストを`Context`トレイトで追加

## 依存関係の追加

新しい依存関係を追加する場合:

1. **必要性を検討**: 既存の依存関係で解決できないか確認
2. **最小限の機能**: `features`で必要な機能のみ有効化
3. **Cargo.tomlに追加**: バージョンは最新の安定版を使用
4. **ドキュメント更新**: `.claude/project-context.md`の技術スタックを更新

## パフォーマンスの考慮

### ボトルネック
現在のボトルネックはPyPI API呼び出し (逐次処理)。最適化する場合:

1. **並列処理**: `tokio`と`reqwest`の非同期版を検討
2. **キャッシュ**: SQLiteでローカルキャッシュを検討
3. **計測**: 変更前後でベンチマーク

### メモリ使用
- パッケージ数が多い場合でも、逐次処理で問題なし
- 大きなJSONを一度にメモリに保持しない

## セキュリティ

### 外部入力の検証
- ファイルパス: パストラバーサルに注意
- API レスポンス: 想定外の形式に備える
- ユーザー入力: CLIオプションの検証

### 機密情報
- API キーなどは不要 (PyPI APIは認証なし)
- エラーメッセージにパス情報を含める際は注意

## テスト戦略

### ユニットテスト
- 各モジュールに`#[cfg(test)]`セクション
- パブリック関数はすべてテスト
- エッジケースを含める

### 統合テスト
- `examples/sample-project`で手動テスト
- 実際のPyPI APIを使用するE2Eテストは慎重に

### テストの実行
```bash
cargo test              # すべてのテスト
cargo test -- --nocapture  # 出力付き
```

## ビルドとリリース

### デバッグビルド
```bash
cargo build
```

### リリースビルド
```bash
cargo build --release
```

### インストール
```bash
cargo install --path .
```

## 環境固有の問題

### Cargo未インストール
プロジェクトファイルを手動で作成する必要がある場合あり

### ネットワーク制限
- PyPI APIへのアクセスが必要
- プロキシ環境では追加設定が必要な場合あり

## バージョニング

Semantic Versioningに従う:
- MAJOR: 互換性のない変更
- MINOR: 後方互換性のある機能追加
- PATCH: 後方互換性のあるバグ修正

## コミットメッセージ

以下の形式を推奨:
```
<type>: <subject>

<body>
```

Types:
- `feat`: 新機能
- `fix`: バグ修正
- `docs`: ドキュメント変更
- `style`: フォーマット変更
- `refactor`: リファクタリング
- `test`: テスト追加・修正
- `chore`: ビルドプロセスなど

## Claude Codeでの作業フロー

1. **コンテキスト確認**: `.claude/project-context.md`を読む
2. **変更箇所の特定**: 関連するモジュールを確認
3. **テストの追加**: 新機能には必ずテストを追加
4. **ビルド確認**: `cargo build`でコンパイルエラーがないか確認
5. **テスト実行**: `cargo test`で既存の機能が壊れていないか確認
6. **ドキュメント更新**: 必要に応じてREADMEなどを更新
7. **フォーマット**: `cargo fmt`でコードをフォーマット
8. **Linting**: `cargo clippy`で警告を確認

## よくある質問

### Q: 新しい出力フォーマットを追加したい
A: 以下の手順:
1. `cli.rs`の`OutputFormat`列挙型に追加
2. 新しいモジュール (例: `spdx.rs`) を作成
3. `main.rs`の`match`文に分岐を追加
4. テストを追加
5. READMEを更新

### Q: エラーメッセージを英語にしたい
A: `error.rs`の`Display`実装を変更。ただし、現在は日本語を想定している。

### Q: パフォーマンスを改善したい
A: 最大のボトルネックはPyPI API呼び出し。並列処理化を検討。

### Q: オフライン動作をサポートしたい
A: ローカルのパッケージメタデータ読み込みを実装。`license.rs`にフォールバックロジックを追加。

## 注意事項

- **破壊的変更は避ける**: 既存のCLIオプションを削除・変更しない
- **下位互換性**: uv.lockの古いバージョンも可能な限りサポート
- **エラーメッセージの一貫性**: 既存のスタイルに合わせる
- **テストの網羅性**: カバレッジを下げない
